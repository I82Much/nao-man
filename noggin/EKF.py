"""
Here we house all of the things to help answer the existential question of
where am I?
"""

from math import pi, sin, cos, atan2, fabs, hypot, e, log

from man.motion import MotionConstants
from . import NogginConstants as Constants
from .util.MyMath import (dist,
                          safe_atan2,
                          sign,
                          sub180Angle,
                          sub180Diff)

# Try to import the c++ matrix library.  If this import fails,
# it means we are testing offline, so then use the python library.
<<<<<<< HEAD:noggin/EKF.py
from ..vision import matrix
=======
try:
    from ..vision import matrix
    OFFLINE = False
except ImportError:
    from .util import Matrix as matrix
    OFFLINE = True
#jf- whats the point of this?  can we just remove all OFFLINE stuff?
#th- no!
>>>>>>> Small commenting changes to EKF.py:skull/noggin/EKF.py
OFFLINE = False


class EKF:
    """
    Class to Localize ourself
    """

    # Debug Switches
    DEBUG_CORNERS = False
    DEBUG_BALL = False
    DEBUG_BALL_VELOCITY_CALC = False
    DEBUG_CORNER_FITTING = False

    # Functional Switches
    PROCESS_CORNERS = False
    PROCESS_ONLY_SPECIFIC_CORNERS = False
    NEAR_BALL_CALC = True

    # Enviornment Paramaters
    ASSUMED_FPS = 50.
    MAX_DELTA_F = 40.#max(Constants.FORWARD_ACTUAL_SPEEDS) / ASSUMED_FPS
    MIN_DELTA_F = -40.#-max(Constants.BACKWARD_ACTUAL_SPEEDS) / ASSUMED_FPS
    MAX_DELTA_L = 40.#max(Constants.LATERAL_ACTUAL_SPEEDS) / ASSUMED_FPS
    MIN_DELTA_L = -MAX_DELTA_L
    QUICKEST_SPIN_TIME = 1.0
    MAX_DELTA_R = 360. / (QUICKEST_SPIN_TIME * 2.0 * ASSUMED_FPS)
    MIN_DELTA_R = -MAX_DELTA_R
    MAX_LINEAR_DISPLACEMENT_FACTOR = 1.0
    MAX_LINEAR_DISPLACEMENT = MAX_DELTA_F * MAX_LINEAR_DISPLACEMENT_FACTOR

    # Ball Environment Parameters
    MAX_BALL_VELOCITY = 150.
    MAX_BALL_VELOCITY_UNCERT = MAX_BALL_VELOCITY * 2.
    MAX_BALL_LINEAR_DISPLACEMENT = MAX_BALL_VELOCITY / ASSUMED_FPS
    VELOCITY_ODOMETRY_DECAY = -0.01
    CARPET_FRICTION = -25 #25 cm/s^2

    # Parameters: self/global
    NUMBER_OF_FRAMES_TO_RECOVER_AFTER_RESET = 100
    INSANITY_COEFFICIENT = 1.0
    CORNER_MAX_VISIBLE_DISTANCE = 160.
    CORNER_MIN_VISIBLE_DISTANCE = 10.
    SUPER_HIGH_CORNER_DIVERGENCE = 300.0
    MAX_CORNER_DIVERGENCE = 150.#CORNER_DISTANCE_THRESH_FROM_SELF_MAX * .75
    OVEREST_FIELD_OF_VIEW = 90.0 # Field of view is overestimated

    # Parameters: ball-specific
    ABSOLUTE_TEAMMATE_BALL_UNCERT_THRESH = 45.
    BALL_DECAY_PERCENT = 0.05
    NEAR_BALL_CALCULATION_DIST = 50.

    # Initial Filter Values
    INITIAL_HEADING = Constants.MY_GOAL_HEADING
    INITIAL_X = Constants.CENTER_FIELD_X
    INITIAL_Y = Constants.CENTER_FIELD_Y
    INITIAL_UNCERT_X  = INITIAL_X ** 2
    INITIAL_UNCERT_Y = INITIAL_Y ** 2
    INITIAL_UNCERT_THETA = 180. ** 2
    INITIAL_BALL_X = INITIAL_X
    INITIAL_BALL_Y = INITIAL_Y
    INITIAL_BALL_X_VELOCITY = 0.
    INITIAL_BALL_Y_VELOCITY = 0.

    # LOC_LIMITs are the bounds for values of the robot's and ball's locations
    # that are considered reasonable
    BOTTOM_LOC_LIMIT = Constants.FIELD_GREEN_BOTTOM_SIDELINE_Y
    TOP_LOC_LIMIT = Constants.FIELD_GREEN_TOP_SIDELINE_Y
    LEFT_LOC_LIMIT = Constants.FIELD_GREEN_LEFT_SIDELINE_X
    RIGHT_LOC_LIMIT = Constants.FIELD_GREEN_RIGHT_SIDELINE_X

    # Error Assumptions
    ASSUMED_VISION_SD_DENOM = 4.
    ASSUMED_VISION_SD_EXPONENT = 1.4
    DISTANCE_MEASUREMENT_SD = (lambda self, d:
                               (d ** self.ASSUMED_VISION_SD_EXPONENT)/
                               self.ASSUMED_VISION_SD_DENOM)
    ASSUMED_CORNER_SD_EXPONENT = 2.0
    CORNER_COEFFICIENT = 0.0125
    CORNER_DISTANCE_MEASUREMENT_SD = (lambda self, d:
				      (d ** self.ASSUMED_CORNER_SD_EXPONENT)*
				      self.CORNER_COEFFICIENT+10)
    ASSUMED_ANGLE_SD = 4.
    NEAR_POST_VARIANCE_THRESH = 100.
    NEAR_POST_VARIANCE_FACTOR = 3.0
    # Variance gathered and formulas generated by excel
    HEAD_SPEED_TO_BEARING_VARIANCE = (lambda self, pwm:
                                          0.0011 * (fabs(pwm) ** 1.8647))
    BEACON_DIST_TO_VARIANCE = (lambda self, dist:
                                   0.0496 * (e ** (.0271 * dist)))
    POST_DIST_TO_VARIANCE = BEACON_DIST_TO_VARIANCE

    # Ball variances
    BALL_DIST_TO_VARIANCE = (lambda self, dist:
                                 (0.00000004)*(dist ** 4.0797))
    BALL_HEAD_SPEED_TO_BEARING_VARIANCE = (lambda self, pwm:
                                               0.0011 * (fabs(pwm) ** 1.8647))
    MIN_BALL_DIST_VARIANCE = 5.
    MAX_BALL_DIST_VARIANCE = 2500.
    ASSUMED_BALL_VISION_SD_DENOM = 3.
    ASSUMED_BALL_ANGLE_SD = 4.

    # Uncertainty growth
    # Self
    BETA = 3.0
    BETA_THETA = .2
    GAMMA = 2.
    ALPHA = 1./3.
    EPSILON = 1.0
    # Ball
    BETA_BALL = 5. # How much uncertainty naturally grows per frame
    GAMMA_BALL = .1 # How much should ball velocity effect uncertainty
    ALPHA_BALL = 1.
    EPSILON_BALL = 1.0
    EPSILON_CLOSE_BALL = 1.0
    # Ball velocity
    BETA_VEL = 1.0
    GAMMA_VEL = 1.0
    ALPHA_VEL = 1.0

    # Teammate ball processing
    TEAMMATE_DIST_VARIANCE_FACTOR = 2.0
    TEAMMATE_BEARING_VARIANCE_FACTOR = 2.0
    TEAMMATE_SELF_UNCERT_THRESH = 300.0

    # Geometric Constants
    RAD_TO_DEG = 360. / (2. * pi);
    DEG_TO_RAD = (2. * pi) / 360.;
    QUAT_CIRC_DEG = 90.;
    HALF_CIRC_DEG = 180.;
    SMALL_NONZERO_NUMBER = 0.1

    def __init__(self,
                 guess_x = INITIAL_X,
                 guess_y = INITIAL_Y,
                 guess_theta = INITIAL_HEADING,
                 guess_uncert_x = INITIAL_UNCERT_X,
                 guess_uncert_y = INITIAL_UNCERT_Y,
                 guess_uncert_theta = INITIAL_UNCERT_THETA,
                 guess_ball_x = INITIAL_BALL_X,
                 guess_ball_y = INITIAL_BALL_Y,
                 guess_ball_velocity_x = INITIAL_BALL_X_VELOCITY,
                 guess_ball_velocity_y = INITIAL_BALL_Y_VELOCITY,
                 guess_ball_x_uncert = INITIAL_UNCERT_X,
                 guess_ball_y_uncert = INITIAL_UNCERT_Y,
                 guess_ball_v_x_uncert = MAX_BALL_VELOCITY_UNCERT,
                 guess_ball_v_y_uncert = MAX_BALL_VELOCITY_UNCERT,
                 framesSinceReset = 0,
                 brain = None):
	"""
	Initialize the Filter, guess an initial location on the field, and
        set the initial uncertainty about that location
	"""
        ## Robot Position ##
	self.P_kminus1 = matrix.withvalues(3, 3, [guess_uncert_x, 0., 0.,\
						  0., guess_uncert_y, 0.,\
 						  0., 0., guess_uncert_theta])
        self.xhat_kminus1 = matrix.withvalues(3, 1, [guess_x,\
						     guess_y,\
						     guess_theta])
	self.by3_identity = matrix.identity(3)
	self.P_k = matrix.Matrix(self.P_kminus1)
	self.xhat_k = matrix.Matrix(self.xhat_kminus1)

	# Initialize empty matrixes for use in updateOdometry()
	self.A_k = matrix.identity(3)
	self.delta_matrix = matrix.Matrix(3, 1, 0.)
	self.xhat_k_priori = matrix.Matrix(3, 1, 0.)
	self.Q_kminus1 = matrix.Matrix(3, 3, 0.)
	self.P_k_priori = matrix.Matrix(3, 3, 0.)

	# Initialize empty matrixes for use in sawSpecificLandmark()
	self.z_x = matrix.Matrix(2, 1, 0.)
	self.d_x = matrix.Matrix(2, 1, 0.)
	self.v_k = matrix.Matrix(2, 1, 0.)
	self.H_k = matrix.Matrix(2, 3, 0.)
	self.R_k = matrix.Matrix(2, 2, 0.)

        # Initialize the ball and ball velocity
	self.init_ball(guess_ball_x, guess_ball_y,
                       guess_ball_velocity_x, guess_ball_velocity_y,
                       guess_ball_x_uncert, guess_ball_y_uncert,
                       guess_ball_v_x_uncert, guess_ball_v_y_uncert)

	## Resetting ##
	self.frames_since_reset = framesSinceReset

	# brain object
	self.brain = brain

    def init_ball(self, guess_ball_x = INITIAL_BALL_X,
                  guess_ball_y = INITIAL_BALL_Y,
                  guess_vel_x = INITIAL_BALL_X_VELOCITY,
		  guess_vel_y = INITIAL_BALL_Y_VELOCITY,
		  guess_b_x_uncert = INITIAL_UNCERT_X,
		  guess_b_y_uncert = INITIAL_UNCERT_Y,
		  guess_v_x_uncert = MAX_BALL_VELOCITY_UNCERT,
		  guess_v_y_uncert = MAX_BALL_VELOCITY_UNCERT):
	"""
	Set up the ball tracking aspect of the filter, guessing the initial
        location of the ball to the be values of the optional paramaters
	"""
	self.Pball_kminus1 = matrix.withvalues(4, 4,
					       [guess_b_x_uncert, 0., 0., 0.,
						0., guess_b_y_uncert, 0., 0.,
						0., 0., guess_v_x_uncert, 0.,
						0., 0., 0., guess_v_y_uncert])

	self.xhatball_kminus1 = matrix.withvalues(4, 1, [guess_ball_x,
							 guess_ball_y,
							 guess_vel_x,
							 guess_vel_y,])
	self.by2_identity = matrix.identity(2)
	self.by4_identity = matrix.identity(4)

        # Set this frame value to last frame values
	self.Pball_k = matrix.Matrix(self.Pball_kminus1)
	self.xhatball_k = matrix.Matrix(self.xhatball_kminus1)

	# Matricies for ball time update
	self.Aball_k = matrix.identity(4)
	self.Aball_k.set(0, 2, 1. / self.ASSUMED_FPS)
	self.Aball_k.set(1, 3, 1. / self.ASSUMED_FPS)
	self.delta_ball_matrix = matrix.Matrix(4, 1, 0.)
	self.xhatball_k_priori = matrix.Matrix(4, 1, 0.)
	self.Qball_kminus1 = matrix.Matrix(4, 4, 0.)
	self.Pball_k_priori = matrix.Matrix(4, 4, 0.)

	# Matricies for ball correction phase
	self.zball_x = matrix.Matrix(2, 1, 0.)
	self.dball_x = matrix.Matrix(2, 1, 0.)
	self.vball_k = matrix.Matrix(2, 1, 0.)
	self.Hball_k = matrix.Matrix(2, 4, 0.)
	self.Rball_k = matrix.Matrix(2, 2, 0.)
	self.lastBallSeenFrame = 0
	self.stopResetingFrame = 0

    def updateOdometry(self, (delta_f, delta_l, delta_r)):
	"""
	Make a priori estimate to account for movement reported by odometry.
        Takes a tuple of form (delta_f, delta_l, delta_r) with units of
        (cm, cm, deg)
	"""

	## Robot Position ##
	# Since we expect exactly 1 updateOdometry() call each frame,
        # increment the frames_since_reset count
	self.frames_since_reset += 1

	# Sanity check the reported odometry deltas.
        # If they are unreasonably large, trim the to reasonable values
	if delta_f > self.MAX_DELTA_F:
	    delta_f = self.MAX_DELTA_F
	if delta_f < self.MIN_DELTA_F:
	    delta_f = self.MIN_DELTA_F
	if delta_l > self.MAX_DELTA_L:
	    delta_l = self.MAX_DELTA_L
	if delta_l < self.MIN_DELTA_L:
	    delta_l = self.MIN_DELTA_L
	if delta_r > self.MAX_DELTA_R:
	    delta_r = self.MAX_DELTA_R
	if delta_r < self.MIN_DELTA_R:
	    delta_r = self.MIN_DELTA_R

	# Determine the angle from which to how much we expect our position to
        # have changed based on the odometry info.
        # I'm honestly not sure why we need to add 90 degrees instead of
        # subtract 90 degrees.  Convert to radians for use in trig functions
	# A: We add 90 because lateral odometery is reported such that
	# positive lateral moves the robot left not right

       	calc_from_angle = (self.xhat_kminus1.get(2, 0) + 90) * self.DEG_TO_RAD
        delta_x = (delta_f * cos(calc_from_angle)) - (delta_l *
                                                      sin(calc_from_angle))
        delta_y = (delta_f * sin(calc_from_angle)) + (delta_l *
                                                      cos(calc_from_angle))
        delta_theta = delta_r

	# Update localization estimate by adding the changes computed from the
        # odometry info to our previous localization info
        self.xhat_k_priori = self.xhat_kminus1.add(
            matrix.withvalues(3, 1, [delta_x,\
                                     delta_y,\
                                     delta_theta]))

	# Correct heading estimate to assure that it is within 180 degrees of
        # zero: all possible headings can be expressed in this range
        self.xhat_k_priori.set(2,0, sub180Angle(self.xhat_k_priori.get(2,0)))

	# Update the input noise covariance matrix based on the odemtry info.
        # The larger the reported movement in any direction, the more
        # uncertain we are about that change
	self.Q_kminus1.set(0, 0, self.ALPHA * (self.BETA + self.GAMMA
                                               *(delta_x ** 2.)))
	self.Q_kminus1.set(1, 1, self.ALPHA * (self.BETA + self.GAMMA
                                               *(delta_y ** 2.)))
	self.Q_kminus1.set(2, 2, self.ALPHA * (self.BETA_THETA + self.GAMMA
                                               *(delta_theta ** 2.)))
	# Update the correction matrix
        # Add the noise described in Q to the uncertainty matrix:
        # the more noise we expect, the less certain we are about our new
        # estimates
	self.P_k_priori = self.P_kminus1.add(self.Q_kminus1)

	# Copy the values of various matricies.
        # These copies are only neccesary becuase we might not be strictely
        # alternating between updateOdometry() and sawSpecificLandmark()
	self.xhat_kminus1 = matrix.Matrix(self.xhat_k_priori)
	self.P_kminus1 = matrix.Matrix(self.P_k_priori)
	self.xhat_k = matrix.Matrix(self.xhat_kminus1)
	self.P_k = matrix.Matrix(self.P_kminus1)
	# Check the reasonableness of the changes induced by the update
	self.sanityCheck()

	#-----Ball Position and Velocity-----#
	# Velocity should not effect position if we haven't seen the
	# ball in a while
	deltaball_x = self.getBallXVelocityEst() * (1. / self.ASSUMED_FPS)
	deltaball_y = self.getBallYVelocityEst() * (1. / self.ASSUMED_FPS)
	delta_v_x = 0.
	delta_v_y = 0.

        delta_v_x = (self.CARPET_FRICTION / self.ASSUMED_FPS *
                     sign(self.getBallXVelocityEst()))
        delta_v_y = (self.CARPET_FRICTION / self.ASSUMED_FPS *
                     sign(self.getBallYVelocityEst()))

        # Clip Ball Values
	if deltaball_x > self.MAX_BALL_VELOCITY / self.ASSUMED_FPS:
	    deltaball_x = self.MAX_BALL_VELOCITY / self.ASSUMED_FPS
	if deltaball_x < -self.MAX_BALL_VELOCITY / self.ASSUMED_FPS:
	    deltaball_x = -self.MAX_BALL_VELOCITY / self.ASSUMED_FPS
	if deltaball_y > self.MAX_BALL_VELOCITY / self.ASSUMED_FPS:
	    deltaball_y = self.MAX_BALL_VELOCITY / self.ASSUMED_FPS
	if deltaball_y < -self.MAX_BALL_VELOCITY / self.ASSUMED_FPS:
	    deltaball_y = -self.MAX_BALL_VELOCITY / self.ASSUMED_FPS

	# Update ball position and velocity estimates
	self.xhatball_k_priori = self.xhatball_kminus1.add(
            matrix.withvalues(4, 1, [deltaball_x, deltaball_y,
				     delta_v_x, delta_v_y]))

	# Update uncertainty associated with ball
	self.Qball_kminus1.set(0, 0, self.ALPHA_BALL *
                               (self.BETA_BALL + self.GAMMA_BALL *
                                (deltaball_x ** 2.)))
	self.Qball_kminus1.set(1, 1, self.ALPHA_BALL *
                               (self.BETA_BALL + self.GAMMA_BALL *
                                (deltaball_y ** 2.)))
	self.Qball_kminus1.set(2, 2, self.BETA_VEL)
	self.Qball_kminus1.set(3, 3, self.BETA_VEL)

	self.Pball_k_priori = self.Aball_k.multiply(
	    self.Pball_kminus1.multiply(self.Aball_k.transpose())).add(
	    self.Qball_kminus1)

	# Update matricies to reflect time change
	self.xhatball_kminus1 = matrix.Matrix(self.xhatball_k_priori)
	self.Pball_kminus1 = matrix.Matrix(self.Pball_k_priori)
	self.xhatball_k = matrix.Matrix(self.xhatball_kminus1)
	self.Pball_k = matrix.Matrix(self.Pball_kminus1)

	# Check the reasonableness of the changes induced by the
        # odometry update, including the calculated velocity
	self.sanityCheckBall()

    def sawSpecificLandmark(self, landmark, is_corner = False):
	"""
	Update our a priori estimate to reflect new information from Vision.
        We can preform multiple such updates between odemetry updates,
        if for example we see multiple beacons in one frame.
        See the Overview document - *update phase*
	"""
	# use simple vision certainties to screen things out
	if not is_corner:
	    # if landmark certainty is not sure (ie not sure which goal post)
	    if landmark.certainty != Constants.SURE:
		return
	    # if dist uncertainty is high
	    elif landmark.distCertainty == Constants.BOTH_UNSURE:
		return
	    # if we reasonably far away from object and height is unsure
	    elif (landmark.distCertainty == Constants.HEIGHT_UNSURE and
		  landmark.dist > Constants.MIDFIELD_Y):
		return

	b_x = landmark.x
	b_y = landmark.y
	z_d = landmark.dist
        z_a = landmark.bearing

        #On the NAO, bearing is no longer flipped
	#if not is_corner: # weird thing, bearing from Vision class if diff
	#    z_a = -landmark.bearing
	#else:
	if is_corner:
            # if a corner is certain distance away, throw it out
	    dist_to_corner_from_self = dist(self.getXEst(),self.getYEst(),
					    landmark.x,landmark.y)

	    if (dist_to_corner_from_self >
		self.CORNER_MAX_VISIBLE_DISTANCE or
		dist_to_corner_from_self <
		self.CORNER_MIN_VISIBLE_DISTANCE):
		if self.DEBUG_CORNER_FITTING:
		    print "Corner distance to far away", \
			dist_to_corner_from_self
		return

	    landmark.localId = cornerIDtoLandmarkID(landmark.localId)

	#debugPrint("sawSpecificLandmark(): %s" %
	#	   (Constants.landmarkTuple[landmark.localId]))

	if (self.brain is not None and Constants.DEBUG_LOC_INFO and
	    not OFFLINE):
	    self.brain.debugLoc.addUsedLandmark(landmark)
	elif OFFLINE and self.brain is not None:
	    self.brain.addUsedLandmark(landmark)

	# Create a vector of the vision information
	self.z_x = matrix.withvalues(2, 1, [z_d, z_a])

	# Calculate the distance and heading angle that we would have expected
        # for this landmark given our previos localizaiton estimate,
        # then create a matrix with those values to use in calculations
	d = ((self.xhat_k_priori.get(0,0) - b_x) ** 2. +
                 (self.xhat_k_priori.get(1,0) - b_y) ** 2.) ** .5

	# Assure that d is nonzero, becuase we will be dividing by it later
	if d == 0:
	    d = self.SMALL_NONZERO_NUMBER

        a = sub180Angle(self.RAD_TO_DEG * safe_atan2(
		b_y - self.xhat_k_priori.get(1,0), b_x -
		self.xhat_k_priori.get(0,0)) - self.QUAT_CIRC_DEG -
                        self.xhat_k_priori.get(2,0))

        # Find an equivalant angle such that a has a Euclidian distance of no
        # more than 180 degrees from z_a: an angle is never really more than
        # 180 degrees different from any other angle.
	a = sub180Diff(a, z_a)
	self.d_x = matrix.withvalues(2, 1, [d, a])
	v_k = self.z_x.subtract(self.d_x);

	# Calculate the values for the jacabian matrix.
        # See the Kalman Overview document for an explanation
        H_k_1_1 = (self.xhat_k_priori.get(0,0) - b_x) / d
        H_k_1_2 = (self.xhat_k_priori.get(1,0) - b_y) / d
        H_k_1_3 = 0.

        H_k_2_1 = -1. * self.RAD_TO_DEG * ((self.xhat_k_priori.get(1,0) - b_y)/
					   d ** 2.)

        H_k_2_2 = self.RAD_TO_DEG * ((self.xhat_k_priori.get(0,0) - b_x)/
				     d ** 2.)

        H_k_2_3 = -1.

        # Create the jacobian matrix
	self.H_k = matrix.withvalues(2, 3, [H_k_1_1, H_k_1_2, H_k_1_3,
                                            H_k_2_1, H_k_2_2, H_k_2_3])

	# Update the measurnment covariance matrix

        # FIX_ME: Redo bearing variance to depend on HEAD_SPEED
        headSpeed = self.brain.motion.getHeadSpeed()
	self.R_k.set(1, 1, self.HEAD_SPEED_TO_BEARING_VARIANCE(headSpeed))

	# Calculate distance variance dependent on landmark type
	if is_corner:
	    self.R_k.set(0, 0, self.CORNER_DISTANCE_MEASUREMENT_SD(z_d))

	elif (landmark.localId == Constants.LANDMARK_MY_GOAL_LEFT_POST_ID or
	      landmark.localId == Constants.LANDMARK_MY_GOAL_RIGHT_POST_ID or
	      landmark.localId == Constants.LANDMARK_OPP_GOAL_LEFT_POST_ID or
	      landmark.localId == Constants.LANDMARK_OPP_GOAL_RIGHT_POST_ID):

	    self.R_k.set(0, 0, self.POST_DIST_TO_VARIANCE(z_d))

	    if z_d < self.NEAR_POST_VARIANCE_THRESH:
		self.R_k.set(1, 1, self.R_k.get(1, 1)*
			     self.NEAR_POST_VARIANCE_FACTOR)

	elif (landmark.localId == Constants.LANDMARK_LEFT_BEACON_ID or
	      landmark.localId == Constants.LANDMARK_RIGHT_BEACON_ID):
	    self.R_k.set(0,0, self.BEACON_DIST_TO_VARIANCE(z_d))
        else:
            print "wtf, mate?"


	# Use the divergence between the recieved and expected localization
        # information to update our expection position and heading
	# First, calculate the Kalman gain, which describes how realitevly
        # heavily to weight the new information
	K_k = self.P_k_priori.multiply(
            self.H_k.transpose().multiply(((self.H_k.multiply(
            self.P_k_priori.multiply(
            self.H_k.transpose()))).add(self.R_k)).invert()))

        # Then use the Kalman gain to compute the absolte amount by which we
        # should change our estimates, and apply those changes
	self.xhat_k = self.xhat_k_priori.add(
            (K_k.multiply(v_k)).scale(self.EPSILON))

	# Before going on, sanity check the updated values to see if they are
        # reasonable, by caping the total displacement to some specified amount
	if not self.isRecoveringFromReset():
	    if self.xhat_k.get(0,0) - self.xhat_k_priori.get(0,0) > \
                   self.MAX_LINEAR_DISPLACEMENT:
		self.xhat_k.set(0,0,self.xhat_k_priori.get(0,0) +
                                self.MAX_LINEAR_DISPLACEMENT)

	    if self.xhat_k.get(0,0) - self.xhat_k_priori.get(0,0) < \
                   -self.MAX_LINEAR_DISPLACEMENT:
		self.xhat_k.set(0,0,self.xhat_k_priori.get(0,0) -
                                self.MAX_LINEAR_DISPLACEMENT)

	    if self.xhat_k.get(1,0) - self.xhat_k_priori.get(1,0) > \
                   self.MAX_LINEAR_DISPLACEMENT:
		self.xhat_k.set(1,0,self.xhat_k_priori.get(1,0) +
                                self.MAX_LINEAR_DISPLACEMENT)

	    if self.xhat_k.get(1,0) - self.xhat_k_priori.get(1,0) < \
                   -self.MAX_LINEAR_DISPLACEMENT:
		self.xhat_k.set(1,0,self.xhat_k_priori.get(1,0) -
                                self.MAX_LINEAR_DISPLACEMENT)

	# Update our uncertainty to reflect the chagnes
	self.P_k = (self.by3_identity.subtract(
            K_k.multiply(self.H_k))).multiply(self.P_k_priori)

	# Copy the values of various matricies.
        # These copies are only neccesary becuase we might not be strictely
        # alternating between updateOdometry() and sawSpecificLandmark()
	self.xhat_k_priori = matrix.Matrix(self.xhat_k)
	self.P_k_priori = matrix.Matrix(self.P_k)
	self.P_kminus1 = matrix.Matrix(self.P_k)
	self.xhat_kminus1 = matrix.Matrix(self.xhat_k)

	# Check the reasonableness of the changes induced by the
        # landmark sighting
	self.sanityCheck()

    def sawBall(self, zball_d, zball_a, isTeammateReport=False,
		teammateDist = 0):
	"""
	Update our a priori estimate of the ball's state to reflect new
        information from Vision.  The procedure is similar to that of
        sawSpecificLandmark.  Note however the critical difference in the
        calculation of Hball_k_1_1 and Hball_k_1_2.
	"""
	if zball_d < self.NEAR_BALL_CALCULATION_DIST and self.NEAR_BALL_CALC:
	    self.sawCloseBall(zball_d, zball_a, isTeammateReport, teammateDist)
	    return

	# Create a vector of the vision information
	self.zball_x = matrix.withvalues(2, 1, [zball_d, zball_a])

	# Calculate the distance and heading angle that we would have expected
        # for the ball given our previos localizaiton estimate, then create a
        # matrix with those values to use in calculations
	dball = ((self.xhat_k_priori.get(0,0) - self.getBallXEst()) ** 2. +
                     (self.xhat_k_priori.get(1,0) - self.getBallYEst()) ** 2. )\
		     ** .5

        # Assure that dball is not 0, becuase we will be dividing by it
	if dball == 0:
	    dball = self.SMALL_NONZERO_NUMBER

	aball = sub180Angle(self.RAD_TO_DEG * safe_atan2(
            self.getBallYEst() - self.xhat_k_priori.get(1,0),
            self.getBallXEst() - self.xhat_k_priori.get(0,0)) -
                            self.QUAT_CIRC_DEG - self.xhat_k_priori.get(2,0))

        # Find an equivalant angle such that a has a Euclidian distance of no
        # more than 180 degrees from zball_a: an angle is never really more
        # than 180 degrees different from any other angle.
	aball = sub180Diff(aball, zball_a)
	self.dball_x = matrix.withvalues(2, 1, [dball,\
						aball])

	vball_k = self.zball_x.subtract(self.dball_x);

	# Calculate the values for the jacabian matrix.
	Hball_k_1_1 = ( (self.getBallXEst() - self.xhat_k_priori.get(0,0)) /
			dball)
	Hball_k_1_2 = ((self.getBallYEst() - self.xhat_k_priori.get(1,0)) /
		       dball)

	# Assure that the divsors are nonzero
	Hball_k_2_1 = -1. * self.RAD_TO_DEG * ((self.getBallYEst() -
						self.xhat_k_priori.get(1,0))
					       / dball ** 2.)

	Hball_k_2_2 = self.RAD_TO_DEG * ((self.getBallXEst() -
					  self.xhat_k_priori.get(0,0)) /
					 dball ** 2.)

	# Create the jacobian matrix
	self.Hball_k = matrix.withvalues(2, 4, [Hball_k_1_1, Hball_k_1_2,0.,0.,
						Hball_k_2_1, Hball_k_2_2,0.,0.])

	# Update the measurnment covariance matrix

	if isTeammateReport:
	    self.Rball_k.set(0, 0, self.BALL_DIST_TO_VARIANCE(teammateDist)*
			     self.TEAMMATE_DIST_VARIANCE_FACTOR)

	    # Limit the range of our function
	    if self.Rball_k.get(0,0) < self.MIN_BALL_DIST_VARIANCE:
		self.Rball_k.set(0, 0, self.MIN_BALL_DIST_VARIANCE)
	    elif self.Rball_k.get(0, 0) > self.MAX_BALL_DIST_VARIANCE:
		self.Rball_k.set(0, 0, self.MAX_BALL_DIST_VARIANCE)

	    self.Rball_k.set(1, 1, self.ASSUMED_BALL_ANGLE_SD)
	else:
	    self.Rball_k.set(0, 0, self.BALL_DIST_TO_VARIANCE(zball_d))

	    # Limit the range of our function
	    if self.Rball_k.get(0,0) < self.MIN_BALL_DIST_VARIANCE:
		self.Rball_k.set(0, 0, self.MIN_BALL_DIST_VARIANCE)
	    elif self.Rball_k.get(0, 0) > self.MAX_BALL_DIST_VARIANCE:
		self.Rball_k.set(0, 0, self.MAX_BALL_DIST_VARIANCE)

            # Calculate a value to determine variance
            # headSpeed = (self.brain.motion.getHeadYawSpeed() +
            #              self.brain.motion.getHeadPitchSpeed() + 1)
            headSpeed = self.brain.motion.getHeadSpeed()

	    self.Rball_k.set(1, 1,
                             self.BALL_HEAD_SPEED_TO_BEARING_VARIANCE(headSpeed))

	    if self.Rball_k.get(1,1) == 0.:
		self.Rball_k.set(1, 1, self.SMALL_NONZERO_NUMBER)
	    #self.Rball_k.set(1, 1, self.ASSUMED_BALL_ANGLE_SD)

	# Calculate Kalman gain matrix
	Kball_k = self.Pball_k_priori.multiply(
            self.Hball_k.transpose().multiply(((self.Hball_k.multiply(
	    self.Pball_k_priori.multiply(self.Hball_k.transpose()))).add(
			self.Rball_k)).invert()))

	# Use kalman gain matrix to determine next estimate
	self.xhatball_k = self.xhatball_k_priori.add(
            (Kball_k.multiply(vball_k)).scale(self.EPSILON_BALL))

	# Before going on, sanity check the updated values to see if they are
        # reasonable, by caping the total displacement to some specified amount
	# if not self.isRecoveringFromReset():
	if self.xhatball_k.get(0,0) - self.xhatball_k_priori.get(0,0) > \
		self.MAX_BALL_LINEAR_DISPLACEMENT:
	    self.xhatball_k.set(0,0,self.xhatball_k_priori.get(0,0) +
				self.MAX_BALL_LINEAR_DISPLACEMENT)

	if self.xhatball_k.get(0,0) - self.xhatball_k_priori.get(0,0) < \
		-self.MAX_BALL_LINEAR_DISPLACEMENT:
	    self.xhatball_k.set(0,0,self.xhatball_k_priori.get(0,0) -
				self.MAX_BALL_LINEAR_DISPLACEMENT)

	if self.xhatball_k.get(1,0) - self.xhatball_k_priori.get(1,0) > \
		self.MAX_BALL_LINEAR_DISPLACEMENT:
	    self.xhatball_k.set(1,0,self.xhatball_k_priori.get(1,0) +
				self.MAX_BALL_LINEAR_DISPLACEMENT)

	if self.xhatball_k.get(1,0) - self.xhatball_k_priori.get(1,0) < \
		-self.MAX_BALL_LINEAR_DISPLACEMENT:
	    self.xhatball_k.set(1,0,self.xhatball_k_priori.get(1,0) -
				self.MAX_BALL_LINEAR_DISPLACEMENT)

	# Update our uncertainty to reflect the chagnes
	self.Pball_k = (self.by4_identity.subtract(
            Kball_k.multiply(self.Hball_k))).multiply(self.Pball_k_priori)

	# Copy the values of various matricies.  These copies are only
        # neccesary becuase we might not be strictely alternating
        # between updateOdometry() and sawSpecificLandmark()
	self.xhatball_k_priori = matrix.Matrix(self.xhatball_k)
	self.Pball_k_priori = matrix.Matrix(self.Pball_k)
	self.Pball_kminus1 = matrix.Matrix(self.Pball_k)
	self.xhatball_kminus1 = matrix.Matrix(self.xhatball_k)

	# Check the reasonableness of the changes induced by the ball sighting
	self.sanityCheckBall(True)
	self.lastBallSeenFrame = self.frames_since_reset


    def sawCloseBall(self, zball_d, zball_a, isTeammateReport = False,
		     teammateDist = 0):
	"""
	Special sawball method to be used when balls are closer than 50 cm's
	Uses relative cartesian coordinates as opposed to polar
	"""
	# Convert our siting to cartesian coordinates
	x_b_r = zball_d * cos(self.DEG_TO_RAD*(zball_a + self.QUAT_CIRC_DEG))
	y_b_r = zball_d * sin(self.DEG_TO_RAD*(zball_a + self.QUAT_CIRC_DEG))
	zball_x = matrix.withvalues(2, 1, [x_b_r,
					   y_b_r])

	# Get expected values of ball
	h = -self.DEG_TO_RAD*self.getHeadingEst()
	x = self.getXEst()
	y = self.getYEst()
	x_b = self.getBallXEst()
	y_b = self.getBallYEst()
	dball_x = matrix.withvalues(2, 1,
				    [(x_b - x)*cos(h) - (y_b - y)*sin(h),
				     (x_b - x)*sin(h) + (y_b - y)*cos(h)])

	# Calculate invariance
	vball_k = zball_x.subtract(dball_x)

	# Calculate jacobians
	Hball_k = matrix.withvalues(2, 4, [cos(h), -sin(h), 0., 0.,
					   sin(h), cos(h), 0., 0.])

	# Update the measurnment covariance matrix
	if isTeammateReport:
	    self.Rball_k.set(0, 0, self.BALL_DIST_TO_VARIANCE(teammateDist)*
			     self.TEAMMATE_DIST_VARIANCE_FACTOR)
	    # Limit the range of our function
	    if self.Rball_k.get(0,0) < self.MIN_BALL_DIST_VARIANCE:
		self.Rball_k.set(0, 0, self.MIN_BALL_DIST_VARIANCE)
	    elif self.Rball_k.get(0, 0) > self.MAX_BALL_DIST_VARIANCE:
		self.Rball_k.set(0, 0, self.MAX_BALL_DIST_VARIANCE)

	    self.Rball_k.set(1, 1, self.BALL_DIST_TO_VARIANCE(teammateDist)*
			     self.TEAMMATE_DIST_VARIANCE_FACTOR)

	    # Limit the range of our function
	    if self.Rball_k.get(1,1) < self.MIN_BALL_DIST_VARIANCE:
		self.Rball_k.set(1, 1, self.MIN_BALL_DIST_VARIANCE)
	    elif self.Rball_k.get(1, 1) > self.MAX_BALL_DIST_VARIANCE:
		self.Rball_k.set(1, 1, self.MAX_BALL_DIST_VARIANCE)
	else:
	    self.Rball_k.set(0, 0, self.BALL_DIST_TO_VARIANCE(zball_d))

	    # Limit the range of our function
	    if self.Rball_k.get(0,0) < self.MIN_BALL_DIST_VARIANCE:
		self.Rball_k.set(0, 0, self.MIN_BALL_DIST_VARIANCE)
	    elif self.Rball_k.get(0, 0) > self.MAX_BALL_DIST_VARIANCE:
		self.Rball_k.set(0, 0, self.MAX_BALL_DIST_VARIANCE)

	    self.Rball_k.set(1, 1, self.BALL_DIST_TO_VARIANCE(zball_d))

	    # Limit the range of our function
	    if self.Rball_k.get(1,1) < self.MIN_BALL_DIST_VARIANCE:
		self.Rball_k.set(1, 1, self.MIN_BALL_DIST_VARIANCE)
	    elif self.Rball_k.get(1, 1) > self.MAX_BALL_DIST_VARIANCE:
		self.Rball_k.set(1, 1, self.MAX_BALL_DIST_VARIANCE)

	# Create our Kalman gain matrix
	Kball_k = self.Pball_k_priori.multiply(
            Hball_k.transpose().multiply(((
			Hball_k.multiply(self.Pball_k_priori.multiply(
				Hball_k.transpose()))).add(
			self.Rball_k)).invert()))

	# Use kalman gain matrix to determine next estimate
	self.xhatball_k = self.xhatball_k_priori.add(
            (Kball_k.multiply(vball_k)).scale(self.EPSILON_CLOSE_BALL))

	# Update our uncertainty to reflect the chagnes
	self.Pball_k = (self.by4_identity.subtract(
            Kball_k.multiply(Hball_k))).multiply(self.Pball_k_priori)

	# Copy matrix values to update our world model
	self.xhatball_k_priori = matrix.Matrix(self.xhatball_k)
	self.Pball_k_priori = matrix.Matrix(self.Pball_k)
	self.Pball_kminus1 = matrix.Matrix(self.Pball_k)
	self.xhatball_kminus1 = matrix.Matrix(self.xhatball_k)

	# Check the reasonableness of the changes induced by the ball sighting
	self.sanityCheckBall(True)
	self.lastBallSeenFrame = self.frames_since_reset

    def ballNotSeen(self):
	"""
	Method to decrease the velocity by BALL_DECAY_PERCENT for every frame
	the ball is not seen.
	"""
	self.setBallXVelocityEst(self.getBallXVelocityEst() *
				 (1. - self.BALL_DECAY_PERCENT))
	self.setBallYVelocityEst(self.getBallYVelocityEst() *
				 (1. - self.BALL_DECAY_PERCENT))
	self.xhatball_k_priori = matrix.Matrix(self.xhatball_k)
	self.xhatball_kminus1 = matrix.Matrix(self.xhatball_k)


    def processTeammateBallReport(self, teammate_packet):
	"""
	Every teamate is constantly broadcasting their point estimates and
        uncertainties for the location of the ball. If this robot does not
        itself have a good idea of where the ball is, perhpas becuase it
        cannot currently see it, it will use the ball location information
        from the other robots to update its own ball estimates.
        Since this robot's own measurnments about the ball are the most import
        for accurately localizing the ball realitive to this robot's own body,
        we only want to incorperate the other robot's estimates if this robot's
        estimates are too poor to be realiable.
	"""
	# Only listen to teammate if we haven't seen a ball for 3 frames
	# And the teammate has reasonable self uncertainty
 	if (teammate_packet.uncertX > self.TEAMMATE_SELF_UNCERT_THRESH or
            teammate_packet.uncertY > self.TEAMMATE_SELF_UNCERT_THRESH):# and
	    # not (teammate_packet.ballDist ==
# 		 Constants.BALL_TEAMMATE_DIST_GRABBING or
# 		 teammate_packet.ballDist ==
# 		 Constants.BALL_TEAMMATE_DIST_DRIBBLING or
# 		 teammate_packet.ballDist ==
# 		 Constants.BALL_TEAMMATE_DIST_KICKING)):
	    return
	else:
	    self.brain.ball.reportBallSeen()
 	    # Calculate the distance and angle at which this agent would see the
	    # ball if this robot were at its estimated location and the ball
	    # was at the teamate's estimate for its location
	    dball = (((self.getXEst() - teammate_packet.ballX) ** 2. +
		      (self.getYEst() - teammate_packet.ballY) ** 2.) ** .5)

	    aball = sub180Angle(self.RAD_TO_DEG * safe_atan2(
                teammate_packet.ballY - self.getYEst(), teammate_packet.ballX -
                self.getXEst()) - self.QUAT_CIRC_DEG - self.getHeadingEst())

	    # Process this faked out ball sighting
	    self.sawBall(dball, aball, True, teammate_packet.ballDist)

    def sawCorners(self, cornerList):
        """
        Method to deal with corners
        This method came about in an effort to make sure multiple corners are
        not matched to the same location on screen.
        Since vision makes sure that the corners we have identified to a
        single possibility are at the very front of the cornerList, the code
        below will immediately send them off to sawSpecificLandmark. This
        helps us have the best possible localization estimate to fit the
        remaining abstract corners. You'll get what I mean when you read
        through this method.
        """
        # There used to be several reasons that we might not want to process
        # any corners. We still keep this around for nostalgic reasons.
	if (not self.PROCESS_CORNERS):
            return

        # Some terminology:
        #  - Concrete corner - a corner as it appears on the field. There are
        #    a total of 14 such corners.
        #  - Visual corner - a corner as it appears in a robot image.

        # The grand purpose of this method is to associate all the visual
        # corners in the current frame to concrete corners on the field.
        # The information we are working with:
        #  - Each visual corner comes with a list of concrete corners that
        #    vision thought it could possibly be. If the list is composed of
        #    one element, then the corner has been positively identified and
        #    and it can be sent over to sawSpecificLandmark.
        #    Otherwise, we'll do some crazy voodoo and associate it with a
        #    single concrete possibility.


        # Code word to say that this concrete corner was matched to a visual
        # corner with 100% certainty by vision. We will want to update
        # localization first and foremost with these corners to improve our
        # estimate of our position before we try to fit the rest of the corners.
        SPECIFIC = -1

        # The following dictionary is a mapping from concrete corners to visual
        # corners. We will try to populate it with the visual corners from the
        # current frame. First off, all the specific corners we saw will
        # be directly inserted into here. The rest of the corners will fight
        # it out for the rest of the possible slot. Only one visual corner is
        # allowoed to match to a concrete corner.
        bestCornerMatch = dict()

        for corner in cornerList:
            #print corner.possibilities
            # Make sure that the vision information is reasonable
            if (not cornerDistanceIsWithinVisibleRadius(corner.dist)):
                if self.DEBUG_CORNERS:
                    debugPrint("returning due to implausible corner distance")
                continue
            if (not self.cornerBearingIsWithinVisibleRadius(corner.bearing)):
                if self.DEBUG_CORNERS:
                    debugPrint("returning due to implausible corner bearing")
                    debugPrint("min visible bearing: %g,\
max visible bearing: %g" %\
                                   (self.cornerMinVisibleBearing(),
                                    self.cornerMaxVisibleBearing()))
                continue

            if isSpecificCorner(corner):
                # If the corner is specific, we're assured that there will
                # only be one possibility. The possibility will be in index 0.
                corner.x = corner.possibilities[0][0]
                corner.y = corner.possibilities[0][1]
                corner.minDivergence = 0
                hashedKey = hash(corner.possibilities[0])
                bestCornerMatch[hashedKey] = SPECIFIC
                # Add our specificCorner immediately
                self.sawSpecificLandmark(corner, True)
            elif len(corner.possibilities) != 0:
                # A guess is composed of a (x,y) tuple that corresponds to
                # a corner location on the field.
                guess = self.fitVisualCornerToConcreteCorner(corner)
                hashOfGuess = hash(guess)
                if guess is not None: # we were able to fit this to a concrete
                    # See if we've already assigned a visual corner to one of
                    # the concrete corners.
                    try:
                        # the following might raise a KeyError
                        curBestCorner = bestCornerMatch[hashOfGuess]
                        # if it didn't, check whether we just found a new
                        # better fit to this concrete corner
                        if guess.minDivergence < curBestCorner.minDivergence:
                            # mark it
                            bestCornerMatch[hashOfGuess] = corner
                            # At this point we could set the old corner away for
                            # a second fitting if we wanted to. I just don't
                            # want to...for now.

                    except KeyError:
                        # there hasn't been a visual corner assigned to this
                        # concrete corner yet, mark it
                        bestCornerMatch[hashOfGuess] = corner

        # Now it's time to send all the information we've piled up on to
        # sawSpecificLandmark()
        # Iteration over a dictionary happens only using keys.
        for hashKey in bestCornerMatch:
            # We have already added specific corners, don't do it again
            corner = bestCornerMatch[hashKey]
            if corner is not SPECIFIC:
                if self.PROCESS_ONLY_SPECIFIC_CORNERS:
                    continue

                if self.DEBUG_CORNERS:
                    debugPrint("Identified corner " + \
                                   cornerString(corner.locID) + \
                                   " with divergence: " + \
                                   repr(corner.minDivergence))
                    debugPrint("   dist: " + repr(corner.dist) + \
                                   " bearing: " + repr(corner.bearing))
                # Here we actually add to the filter
                #print corner
                self.sawSpecificLandmark(corner, True)

    def fitVisualCornerToConcreteCorner(self, abstractCorner):
        #if self.brain.my.playerNumber == 1:
        # if self.brain.goalieInGoal:
#             specific_corners_for_type = goalieSpecificCornersForType(
#                 abstractCorner.visionID)
#         else:
#             specific_corners_for_type = specificCornersForType(
#                 abstractCorner.visionID)

        if self.isRecoveringFromReset():
            if self.DEBUG_CORNERS:
                debugPrint("Recovering from reset. Disregarding abstract \
corner.")
                return None

        abstractCorner.divergences = \
            [self.cornerMeasurementDivergence(abstractCorner, concreteCorner) \
                 for concreteCorner in abstractCorner.possibilities]
        #print ""
        #print ""
        #print ""
        #print abstractCorner.possibilities
        #print ""
        #print ""
        #print ""
        #abstractCorner.divergences = \
        #    [self.cornerMeasurementDivergence(abstractCorner) \
        #         for abstractCorner.visionID in \
        #         specific_corners_for_type]

        if self.DEBUG_CORNERS:
            debugPrint("corner divergences: "+repr(abstractCorner.divergences))
            debugPrint("minumum convergence: " + \
                           repr(min(abstractCorner.divergences)))

        minDivergence = min(abstractCorner.divergences)
        if minDivergence < self.MAX_CORNER_DIVERGENCE:
            index = abstractCorner.divergences.index(minDivergence)
            abstractCorner.x = abstractCorner.possibilities[index][0]
            abstractCorner.y = abstractCorner.possibilities[index][1]
            #abstractCorner.x = cornerX(guessedCornerID)
            #abstractCorner.y = cornerY(guessedCornerID)
            abstractCorner.minDivergence = minDivergence

            #if self.DEBUG_CORNERS:
            #    debugPrint("\tSaw abstract corner: " \
            #                   + cornerString(abstractCorner.locID))

            return abstractCorner

        return None
    def cornerMeasurementDivergence(self, abstractCorner, concreteCorner):
        """
        This method takes an abstract corner which contains distance and bearing
        information in the form of an object of type Corner (see TypeDefs.py)
        and a concreteCorner which is a tuple of the form (x,y).
        It returns how closely the abstract corner fits to this concrete corner
        on an arbitrary scale called forthwith called 'divergence'.
        """
	#if self.DEBUG_CORNERS:
	#    debugPrint("--- calculating divergence for " +
	#	       cornerString(corner.visionID))
	predicted_corner_x = (self.getXEst() +
			      cos(((self.getHeadingEst() +
				    abstractCorner.bearing + 90.0) *
				   self.DEG_TO_RAD)) *
			      abstractCorner.dist)
	predicted_corner_y = (self.getYEst() +
			      sin(((self.getHeadingEst() +
				    abstractCorner.bearing + 90.0) *
				   self.DEG_TO_RAD)) *
			      abstractCorner.dist)
        x_divergence = predicted_corner_x - concreteCorner[0]
        y_divergence = predicted_corner_y - concreteCorner[1]
	#x_divergence = predicted_corner_x - cornerX(corner.visionID)
	#y_divergence = predicted_corner_y - cornerY(corner.visionID)

	a = sub180Angle(-self.RAD_TO_DEG * safe_atan2(
                concreteCorner[0] - self.xhat_k_priori.get(0,0),
                concreteCorner[1] - self.xhat_k_priori.get(1,0))
		#cornerX(corner.visionID) - self.xhat_k_priori.get(0,0),
		#cornerY(corner.visionID) - self.xhat_k_priori.get(1,0))
			- self.xhat_k_priori.get(2,0))
        if self.DEBUG_CORNERS:
            debugPrint("------Min: %f\t Bearing: %f \tMax: %f------" %
                       (self.cornerMinVisibleBearing(), a,
                        self.cornerMaxVisibleBearing()))
 	if not self.cornerBearingIsWithinVisibleRadius(a):
 	    return self.SUPER_HIGH_CORNER_DIVERGENCE

	if self.DEBUG_CORNER_FITTING:
	    debugPrint("------Corner in visual bearing range,\
still candidate------")

	total_divergence = hypot(x_divergence, y_divergence)

	if self.DEBUG_CORNERS:
	    debugPrint("--- x_divergence:" + repr(x_divergence) +
		       "   y_divergence:" + repr(y_divergence))
	    debugPrint("--- total_divergence:" + repr(total_divergence))
	return total_divergence

    def sanityCheck(self):
	"""
	Checks the reasonableness of the filters estimates for position and
        uncertainty, modifying them if they are implausible or impossible.
	"""
	# Make sure that the robot thinks he is on the field.
        # If he doesn't then bring him back on.
	if self.getXEst() < self.LEFT_LOC_LIMIT:
	    self.setXEst(self.LEFT_LOC_LIMIT)
	if self.getXEst() > self.RIGHT_LOC_LIMIT:
	    self.setXEst(self.RIGHT_LOC_LIMIT)
	if self.getYEst() < self.BOTTOM_LOC_LIMIT:
	    self.setYEst(self.BOTTOM_LOC_LIMIT)
	if self.getYEst() > self.TOP_LOC_LIMIT:
	    self.setYEst(self.TOP_LOC_LIMIT)

	# Make sure that the robot's uncertainty estimates are reasonable.
        # The uncertainty in any direction never needs to be more than, 1/2 of
        # the range of possible values for the 95% confidence interval to
        # include essentially the entire field.
	if self.getXUncert() > Constants.FIELD_WIDTH * \
               self.INSANITY_COEFFICIENT:
	    self.setXUncert(Constants.FIELD_WIDTH * self.INSANITY_COEFFICIENT)

	if self.getYUncert() > Constants.FIELD_WIDTH * \
               self.INSANITY_COEFFICIENT:
	    self.setYUncert(Constants.FIELD_WIDTH * self.INSANITY_COEFFICIENT)

	# Similarly, the uncertainty of the heading need not be any more that
        # 180 degrees, as an uncertainty of 180 represents having no idea what
        # your heading is.
	if self.getHeadingUncert() > self.HALF_CIRC_DEG:
	    self.setHeadingUncert(self.HALF_CIRC_DEG)


    def sanityCheckBall(self, sawBall = False):
	"""
	Checks the reasonableness of the filters estimates for position and
        uncertainty of the ball, modifying them if they are implausible or
        impossible.
	"""
	# Make sure that the robot thinks that the ball is on the field.
        # If he doesn't then bring the ball back on. TESTME
	if self.getBallXEst() < self.LEFT_LOC_LIMIT:
 	    self.setBallXEst(self.LEFT_LOC_LIMIT)
 	if self.getBallXEst() > self.RIGHT_LOC_LIMIT:
 	    self.setBallXEst(self.RIGHT_LOC_LIMIT)
 	if self.getBallYEst() < self.BOTTOM_LOC_LIMIT:
 	    self.setBallYEst(self.BOTTOM_LOC_LIMIT)
 	if self.getBallYEst() > self.TOP_LOC_LIMIT:
 	    self.setBallYEst(self.TOP_LOC_LIMIT)

	# Make sure that the robot's uncertainty estimates about the
        # location and velocity of the ball are reasonable
	if self.getBallXUncert() > Constants.FIELD_WIDTH * \
               self.INSANITY_COEFFICIENT:
	    self.setBallXUncert(Constants.FIELD_WIDTH *
                                self.INSANITY_COEFFICIENT)

	if self.getBallYUncert() > Constants.FIELD_WIDTH * \
               self.INSANITY_COEFFICIENT:
	    self.setBallYUncert(Constants.FIELD_WIDTH *
                                self.INSANITY_COEFFICIENT)

	if self.getBallXVelocityUncert() > Constants.FIELD_WIDTH * \
		self.INSANITY_COEFFICIENT:
	    self.setBallXVelocityUncert(Constants.FIELD_WIDTH *
					self.INSANITY_COEFFICIENT)

	if self.getBallYVelocityUncert() > Constants.FIELD_WIDTH * \
		self.INSANITY_COEFFICIENT:
	    self.setBallYVelocityUncert(Constants.FIELD_WIDTH *
					self.INSANITY_COEFFICIENT)

	# If ball has only been recorded for a few frames, assume no velocity
	# But don't reset on odometery.
	if (self.frames_since_reset - self.lastBallSeenFrame > 3 and
	    sawBall):
	    self.stopResetingFrame = 20.
	    #print "Reseting ball velocity"
	    self.setBallXVelocityEst(0.)
	    self.setBallYVelocityEst(0.)

	if self.frames_since_reset - self.stopResetingFrame <= 0:
	    #print "\tStill reseting ball velocity"
	    self.setBallXVelocityEst(0.)
	    self.setBallYVelocityEst(0.)

	# Make sure that the robot has a reasonable estimate of ball velocity
 	if self.getBallXVelocityEst() < -self.MAX_BALL_VELOCITY:
	    self.setBallXVelocityEst(0.)
	    self.setBallYVelocityEst(0.)
	if self.getBallXVelocityEst() > self.MAX_BALL_VELOCITY:
	    self.setBallXVelocityEst(0.)
	    self.setBallYVelocityEst(0.)
	if self.getBallYVelocityEst() < -self.MAX_BALL_VELOCITY:
	    self.setBallXVelocityEst(0.)
	    self.setBallYVelocityEst(0.)
	if self.getBallYVelocityEst() > self.MAX_BALL_VELOCITY:
	    self.setBallXVelocityEst(0.)
	    self.setBallYVelocityEst(0.)

    def reset(self, to_x = INITIAL_X, to_y = INITIAL_Y,
              to_heading = INITIAL_HEADING, brainObj=None):
	"""
	Reset the robot's assumed positions and uncertainties to reflect an
        expected new location of the robot on the field, for example after
        re-entering from a penalty.  If called without the optional arguments,
        resets the robot location to its default initial state.
        Always resets the ball location to its initial default.
	"""
	self.__init__(to_x, to_y, to_heading, brain=brainObj)

    def resetBall(self, to_ball_x = INITIAL_BALL_X,
                  to_ball_y = INITIAL_BALL_Y):
	"""
	Resets the ball filter's assumed positions and uncertainteis to
        reflect an expected new locaiton of the ball on the field, for
        example moving the ball to the midfield line after it goes out of
        bounds.  If called without the optional arguments, resets the ball
        location to its initial default.  Does not affect the robot's estimated
        location or uncertainty.
	"""
	self.init_ball(to_ball_x, to_ball_y)

    def isRecoveringFromReset(self):
	"""
	Indicates weather the filter is recovering from reseting,
        probably due to initialization or known kidnapping.
	"""
	return self.frames_since_reset < \
               self.NUMBER_OF_FRAMES_TO_RECOVER_AFTER_RESET

    # Robot Position
    def getXEst(self):
	"""
	Returns the robot's estimate of its current X coordinate on the field
	"""
	return self.xhat_k.get(0,0)

    def getYEst(self):
	"""
	Returns the robot's estimate of its current Y coordinate on the field
	"""
	return self.xhat_k.get(1,0)

    def getHeadingEst(self):
	"""
	Returns the robot's estimate of its current heading
	"""
	return self.xhat_k.get(2,0)

    def getXUncert(self):
	"""
	Returns the standard deviation of robot's estimate of its current X
        coordinate
	"""
	return self.P_k.get(0,0)

    def getYUncert(self):
	"""
	Returns the standard deviation of robot's estimate of its current Y
        coordinate
	"""
	return self.P_k.get(1,1)

    def getHeadingUncert(self):
	"""
	Returns the standard deviation of robot's estimate of its current heading
	"""
	return self.P_k.get(2,2)

    def setXEst(self, to_x):
	"""
	Sets the robot's estimate of its current X coordinate on the field
	"""
	self.xhat_k.set(0, 0, to_x)

    def setYEst(self, to_y):
	"""
	Sets the robot's estimate of its current Y coordinate on the field
	"""
	self.xhat_k.set(1, 0, to_y)

    def setHeadingEst(self, to_heading):
	"""
	Sets the robot's estimate of its current heading
	"""
	self.xhat_k.set(2, 0, to_heading)

    def setXUncert(self, to_x_uncert):
	"""
	Sets the standard deviation of robot's estimate of its current X
        coordinate
	"""
	self.P_k.set(0, 0, to_x_uncert)

    def setYUncert(self, to_y_uncert):
	"""
	Sets the standard deviation of robot's estimate of its current Y
        coordinate
	"""
	self.P_k.set(1, 1, to_y_uncert)

    def setHeadingUncert(self, to_heading_uncert):
	"""
	Sets the standard deviation of robot's estimate of its current heading
	"""
	self.P_k.set(2, 2, to_heading_uncert)

    # Ball position
    def getBallXEst(self):
	"""
	Returns the robot's estimate of the ball's current X coordinate on the
        field
	"""
	return self.xhatball_k.get(0,0)

    def getBallYEst(self):
	"""
	Returns the robot's estimate of the ball's current Y coordinate on the
        field
	"""
	return self.xhatball_k.get(1,0)

    def getBallXUncert(self):
	"""
	Returns the standard deviation of robot's estimate of the ball's current
        X coordinate
	"""
	return self.Pball_k.get(0,0)

    def getBallYUncert(self):
	"""
	Returns the standard deviation of robot's estimate of the ball's current
        Y coordinate
	"""
	return self.Pball_k.get(1,1)

    def getBallSD(self):
	"""
	Returns the combined standard deviation of the robots estimates of the
        ball's current X and Y coordinates
	"""
	return hypot(self.getBallXUncert(), self.getBallYUncert())

    def setBallXEst(self, to_x):
	"""
	Sets the robot's estimate of the ball's current X coordinate
	"""
	self.xhatball_k.set(0, 0, to_x)

    def setBallYEst(self, to_y):
	"""
	Sets the robot's estimate of the ball's current Y coordinate
	"""
	self.xhatball_k.set(1, 0, to_y)

    def setBallXUncert(self, to_x_uncert):
	"""
	Sets the standard deviation of robot's estimate of the ball's current X
        coordinate
	"""
	self.Pball_k.set(0, 0, to_x_uncert)

    def setBallYUncert(self, to_y_uncert):
	"""
	Sets the standard deviation of robot's estimate of the ball's current Y
        coordinate
	"""
	self.Pball_k.set(1, 1, to_y_uncert)

    # Ball Velocity
    def getBallXVelocityEst(self):
	"""
	Returns the robot's estimate of the x component of the ball's current
        velocity
	"""
	return self.xhatball_k.get(2,0)

    def getBallYVelocityEst(self):
	"""
	Returns the robot's estimate of the y component of the ball's current
        velocity
	"""
	return self.xhatball_k.get(3,0)

    def getBallXVelocityUncert(self):
	"""
	Returns the standard deviation of robot's estimate of the ball's current
        X velocity
	"""
	return self.Pball_k.get(2,2)

    def getBallYVelocityUncert(self):
	"""
	Returns the standard deviation of robot's estimate of the ball's current
        Y velocity
	"""
	return self.Pball_k.get(3,3)

    def getBallVelocitySD(self):
	"""
	Returns the combined standard deviation of the robots estimates of the
        ball's current X and Y velocity
	"""
	return hypot(self.getBallXVelocityUncert(),
                     self.getBallYVelocityUncert())

    def setBallXVelocityEst(self, to_x_vel):
	"""
	Sets the robot's estimate of the ball's current X velocity
	"""
	self.xhatball_k.set(2,0, to_x_vel)

    def setBallYVelocityEst(self, to_y_vel):
	"""
	Sets the robot's estimate of the ball's current Y velocity
	"""
	self.xhatball_k.set(3,0, to_y_vel)

    def setBallXVelocityUncert(self, to_x_uncert):
	"""
	Sets the standard deviation of robot's estimate of the ball's current X
        velocity
	"""
	self.Pball_k.set(2, 2, to_x_uncert)

    def setBallYVelocityUncert(self, to_y_uncert):
	"""
	Sets the standard deviation of robot's estimate of the ball's current Y
        velocity
	"""
	self.Pball_k.set(3, 3, to_y_uncert)

    def debugBall(self, header):
	debugPrint(header)
	debugPrint("ball x: " + repr(self.getBallXEst()))
	debugPrint("ball y: " + repr(self.getBallYEst()))
	debugPrint("ball x velocity: " + repr(self.getBallXVelocityEst()))
	debugPrint("ball y velocity: " + repr(self.getBallYVelocityEst()))
	debugPrint("")

    def cornerBearingIsWithinVisibleRadius(self, bearing_to_corner):
	'''checks to see if corner distance is within allowable range'''
	return ( self.cornerMinVisibleBearing() < bearing_to_corner <
		 self.cornerMaxVisibleBearing())

    def cornerMinVisibleBearing(self):
	''' Minimum posibble bearing that can be seen'''
        return (self.brain.sensors.angles[MotionConstants.HeadYaw]-
		self.OVEREST_FIELD_OF_VIEW / 2.)

    def cornerMaxVisibleBearing(self):
	''' Maximum posibble bearing that can be seen'''
	return (self.brain.sensors.angles[MotionConstants.HeadYaw]+
		self.OVEREST_FIELD_OF_VIEW / 2.)

def debugPrint(string):
    print "debug: ", string

# Methods for dealing with corners
def cornerInfo(corner_id):
    """
    Returns a tuple whose items contain information about various aspects of
    the corner.  See the below methods and Constants.py
    """
    return Constants.CORNER_INFO_DICT[corner_id]

def cornerType(corner_id):
    """
    Returns an integer constant representing the type of corner, i.e. the
    level of abstraction.
    """
    return cornerInfo(corner_id)[Constants.CORNER_ABSTRACTION_LEVEL_INFO]


def isSpecificCorner(corner):
    """
    Returns a boolean value indicating whether the argument represents a
    single, specific corner.  For example, the argument
    Constants.BLUE_CORNER_LEFT_L returns 'True' and the arguments
    Constants.BLUE_GOAL_OUTER_L or L_OUTER_CORNER return 'False'
    """
    return len(corner.possibilities) == 1

def isNarrowlyAbstractCorner(corner_id):
    """
    Returns a boolean value indicating whether the argument represents an
    abstract corner type that can represent one of a few specific corners.
    For example, the argument Constants.BLUE_CORNER_LEFT_L returns 'False'
    (too specific), Constants.BLUE_GOAL_OUTER_L returns 'True', and
    L_OUTER_CORNER returns 'False' (too abstract).
    """
    return cornerType(corner_id) == Constants.NARROWLY_ABSTRACT_CORNER

def isCompletelyAbstractCorner(corner_id):
    """
    Returns a boolean value indicating whether the argument represents an
    abstract corner type that can represent one of many specific corners.
    For example, the argument Constants.BLUE_CORNER_LEFT_L or
    Constants.BLUE_GOAL_OUTER_L return 'False' and L_OUTER_CORNER
    returns 'True'.
    """
    return cornerType(corner_id)== Constants.COMPLETELY_ABSTRACT_CORNER

def specificCornersForType(corner_id):
    """
    Returns a list of all of the specific corners that could be represented by
    the given abstract type.  The abstract type can be narrow or complete, as
    defined above.  For example, the argument 'Constants.CENTER_T' would
    return [Constants.CENTER_LEFT_T, Constants.CENTER_RIGHT_T].
    """
    return Constants.SPECIFIC_CORNERS_FOR_TYPE_DICT[corner_id]

def getTypeIndex(corner_id):
    return Constants.CORNER_TYPE_INDEX_DICT[corner_id]

def cornerX(corner_id):
    """
    Returns the x location of the specifc corner.
    """
    return cornerInfo(corner_id)[Constants.CORNER_X_CORD]

def cornerY(corner_id):
    """
    Returns the y location of the specifc corner.
    """
    return cornerInfo(corner_id)[Constants.CORNER_Y_CORD]

def cornerString(corner_id):
    """
    Returns a human-readable string describing the corner or corner class.
    """
    return cornerInfo(corner_id)[Constants.CORNER_DESCRIPTION_STRING]

def cornerDistanceIsWithinVisibleRadius(distance_to_corner):
    '''checks to see if corner distance is within allowable range'''
    return (distance_to_corner < EKF.CORNER_MAX_VISIBLE_DISTANCE and
	    distance_to_corner > EKF.CORNER_MIN_VISIBLE_DISTANCE)

def cornerIDtoLandmarkID(id):
    return_id = 0
    if id == Constants.MY_CORNER_LEFT_L:
	return_id = Constants.LANDMARK_MY_CORNER_LEFT_L
    elif id == Constants.MY_CORNER_RIGHT_L:
	return_id = Constants.LANDMARK_MY_CORNER_RIGHT_L
    elif id == Constants.MY_GOAL_LEFT_L:
	return_id = Constants.LANDMARK_MY_GOAL_LEFT_L
    elif id == Constants.MY_GOAL_RIGHT_L:
	return_id = Constants.LANDMARK_MY_GOAL_RIGHT_L
    elif id == Constants.MY_GOAL_LEFT_T:
	return_id = Constants.LANDMARK_MY_GOAL_LEFT_T
    elif id == Constants.MY_GOAL_RIGHT_T:
	return_id = Constants.LANDMARK_MY_GOAL_RIGHT_T
    elif id == Constants.CENTER_BY_T:
	return_id = Constants.LANDMARK_CENTER_LEFT_T
    elif id == Constants.CENTER_YB_T:
	return_id = Constants.LANDMARK_CENTER_RIGHT_T
    elif id == Constants.OPP_CORNER_LEFT_L:
	return_id = Constants.LANDMARK_OPP_CORNER_LEFT_L
    elif id == Constants.OPP_CORNER_RIGHT_L:
	return_id = Constants.LANDMARK_OPP_CORNER_RIGHT_L
    elif id == Constants.OPP_GOAL_LEFT_L:
	return_id = Constants.LANDMARK_OPP_GOAL_LEFT_L
    elif id == Constants.OPP_GOAL_RIGHT_L:
	return_id = Constants.LANDMARK_OPP_GOAL_RIGHT_L
    elif id == Constants.OPP_GOAL_LEFT_T:
	return_id = Constants.LANDMARK_OPP_GOAL_LEFT_T
    elif id == Constants.OPP_GOAL_RIGHT_T:
	return_id = Constants.LANDMARK_OPP_GOAL_RIGHT_T
    else:
	debugPrint("cornerIDtoLandmarkID can't find cornerID")
    #debugPrint("cornerID: %s to landmarkID: %s" % (Constants.visionCornerTuple[int(id)], Constants.landmarkTuple[return_id]))
    return return_id
